# URL Shortener

## Functional requirements
1. Short URL generation: generate a unique shorter alias of the given URL.
2. Redirection: Given a short link, redirect the user to the original URL.
3. Custom short links: Users should be able to generate custom short links for their URLs using our system.
4. Deletion: Users should be able to delete a short link generated by our system, given the rights.
5. Update: Users should be able to update the long URL associated with the short link, given the proper rights.
6. Expiry time: There must be a default expiration time for the short links, but users should be able to set the expiration time based on their requirements.

## Non-Functional requirements
- Availability: 
    - Our system should be highly available, because even a fraction of the second downtime would result in URL redirection failures. 
    - Since our system’s domain is in URLs, we don’t have the leverage of downtime, and our design must have fault-tolerance conditions instilled in it.
- Scalability: 
    - Our system should be horizontally scalable with increasing demand.
- Readability: 
    - The short links generated by our system should be easily readable, distinguishable, and typeable.
- Latency: 
    - The system should perform at low latency to provide the user with a smooth experience.
- Unpredictability: 
    - From a security standpoint, the short links generated by our system should be highly unpredictable
    - This ensures that the next-in-line short URL is not serially produced, eliminating the possibility of someone guessing all the short URLs that our system has ever produced or will produce.

---

## Build and run
Using docker, one can start both the services - `shortify` and `snowflake`
```sh
docker-compose up -d
```

---

## Shortify Service

The **Shortify service** is responsible for generating short URLs by accepting long URLs (and optional custom aliases) and returning a shortened URL. It communicates with the Snowflake service to obtain unique IDs for each short URL.

### How it works

1. **Request:**  
   Send a POST request to the Shortify service with a JSON body containing the long URL and (optionally) a custom alias.

   **Example:**
   ```sh
   curl -X POST http://localhost:8081/shortify \
     -H "Content-Type: application/json" \
     -d '{"long_url": "https://www.google.com"}'
   ```

2. **Response:**  
   The service responds with a JSON object containing the original long URL, the generated short URL, and the unique ID.

   **Example response:**
   ```json
   {
     "long_url": "https://www.google.com",
     "short_url": "http://short.ify/k9d8F2xZ1Qw",
     "id": "k9d8F2xZ1Qw"
   }
   ```

### Features

- **Custom Aliases:**  
  You can provide an `alias` field in the request to use a custom short code, if available.

- **Validation:**  
  The service validates the long URL format and the alias (if provided).

- **Integration:**  
  The service calls the Snowflake service to generate a unique ID if no alias is provided.

### Example request with custom alias

```sh
curl -X POST http://localhost:8081/shortify \
  -H "Content-Type: application/json" \
  -d '{"long_url": "https://www.google.com", "alias": "goog"}'
```

---

## ID Generation with Snowflake

This URL shortener uses the [Snowflake algorithm](https://en.wikipedia.org/wiki/Snowflake_ID) to generate unique, time-ordered IDs for each short URL. Snowflake is a distributed unique ID generator inspired by Twitter's Snowflake, ensuring that each generated ID is:

- **Globally unique**: No two IDs are the same, even across distributed systems.
- **Roughly ordered by time**: IDs generated later are numerically larger, which can be useful for sorting or analytics.
- **Efficient**: Generates IDs quickly with minimal coordination between nodes.

### How it works

Each time a new short URL is created, the system generates a 64-bit integer ID using the Snowflake algorithm. This ID encodes:

- The current timestamp
- A machine or process identifier
- A sequence number for IDs generated in the same millisecond

This 64-bit integer is then **encoded in base62** (using digits, uppercase, and lowercase letters) to produce a compact, URL-friendly short code.

### Example

1. **Generate Snowflake ID:**  
   `1396379767275520000`

2. **Encode in base62:**  
   `k9d8F2xZ1Qw`

3. **Short URL:**  
   `https://yourdomain.com/k9d8F2xZ1Qw`

### Benefits

- **Scalability:** Multiple servers can generate IDs independently without collisions.
- **Performance:** No need for centralized coordination or database locking.
- **Security:** Base62 encoding makes short URLs compact and hard to guess.

**Note:**  
The maximum length of a base62-encoded Snowflake ID is 11 characters, ensuring short and user-friendly URLs.

### Sample Request

```sh
curl -X GET http://localhost:8080/generate
```

### Benchmark
```sh
Running tool: /usr/local/go/bin/go test -benchmem -run=^$ -bench ^BenchmarkNext$ github.com/krishnadwypayan/shorturl/internal/snowflake

goos: darwin
goarch: arm64
pkg: github.com/krishnadwypayan/shorturl/internal/snowflake
cpu: Apple M3 Max
=== RUN   BenchmarkNext
BenchmarkNext
BenchmarkNext-14         4928491               244.0 ns/op            56 B/op          2 allocs/op
PASS
ok      github.com/krishnadwypayan/shorturl/internal/snowflake  1.607s
```

---
