# URL Shortener
---

## Functional requirements
1. Short URL generation: generate a unique shorter alias of the given URL.
2. Redirection: Given a short link, redirect the user to the original URL.
3. Custom short links: Users should be able to generate custom short links for their URLs using our system.
4. Deletion: Users should be able to delete a short link generated by our system, given the rights.
5. Update: Users should be able to update the long URL associated with the short link, given the proper rights.
6. Expiry time: There must be a default expiration time for the short links, but users should be able to set the expiration time based on their requirements.

## Non-Functional requirements
- Availability: 
    - Our system should be highly available, because even a fraction of the second downtime would result in URL redirection failures. 
    - Since our system’s domain is in URLs, we don’t have the leverage of downtime, and our design must have fault-tolerance conditions instilled in it.
- Scalability: 
    - Our system should be horizontally scalable with increasing demand.
- Readability: 
    - The short links generated by our system should be easily readable, distinguishable, and typeable.
- Latency: 
    - The system should perform at low latency to provide the user with a smooth experience.
- Unpredictability: 
    - From a security standpoint, the short links generated by our system should be highly unpredictable
    - This ensures that the next-in-line short URL is not serially produced, eliminating the possibility of someone guessing all the short URLs that our system has ever produced or will produce.

---

## ID Generation with Snowflake

This URL shortener uses the [Snowflake algorithm](https://en.wikipedia.org/wiki/Snowflake_ID) to generate unique, time-ordered IDs for each short URL. Snowflake is a distributed unique ID generator inspired by Twitter's Snowflake, ensuring that each generated ID is:

- **Globally unique**: No two IDs are the same, even across distributed systems.
- **Roughly ordered by time**: IDs generated later are numerically larger, which can be useful for sorting or analytics.
- **Efficient**: Generates IDs quickly with minimal coordination between nodes.

### How it works

Each time a new short URL is created, the system generates a 64-bit integer ID using the Snowflake algorithm. This ID encodes:

- The current timestamp
- A machine or process identifier
- A sequence number for IDs generated in the same millisecond

This 64-bit integer is then **encoded in base62** (using digits, uppercase, and lowercase letters) to produce a compact, URL-friendly short code.

### Example

1. **Generate Snowflake ID:**  
   `1396379767275520000`

2. **Encode in base62:**  
   `k9d8F2xZ1Qw`

3. **Short URL:**  
   `https://yourdomain.com/k9d8F2xZ1Qw`

### Benefits

- **Scalability:** Multiple servers can generate IDs independently without collisions.
- **Performance:** No need for centralized coordination or database locking.
- **Security:** Base62 encoding makes short URLs compact and hard to guess.

**Note:**  
The maximum length of a base62-encoded Snowflake ID is 11 characters, ensuring short and user-friendly URLs.

### Build and run snowflake
```sh
go build -o bin/snowflake ./cmd/snowflake && ./bin/snowflake
```

---
